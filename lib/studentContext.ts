import type { Student, StudentContextDocument } from '@prisma/client';
import prisma from './prisma';

export const SUBJECT_LABELS = {
  math: '数学',
  science: '理科',
  english: '英語',
  'social-studies': '社会',
  japanese: '国語'
} as const;

export type SubjectId = keyof typeof SUBJECT_LABELS;

const AUTO_SECTION_START = '<!-- AUTO-CONTEXT-START -->';
const AUTO_SECTION_END = '<!-- AUTO-CONTEXT-END -->';

type StudentWithOptionalContext = Pick<
  Student,
  'email' | 'grade' | 'favoriteSubject' | 'mockExamScore'
> & {
  contextDocument?: StudentContextDocument | null;
};

type MaybeStudent = StudentWithOptionalContext | null | undefined;

function formatGrade(grade: StudentWithOptionalContext['grade']): string {
  if (grade == null) return '学年未設定';
  const gradeNumber = Number(grade);
  if (Number.isNaN(gradeNumber) || gradeNumber < 1 || gradeNumber > 3) {
    return '学年未設定';
  }
  return `中学${gradeNumber}年生`;
}

function formatSubject(subject: StudentWithOptionalContext['favoriteSubject']): string {
  if (!subject || !SUBJECT_LABELS[subject as SubjectId]) return '未設定';
  return SUBJECT_LABELS[subject as SubjectId];
}

function formatMockScore(score: StudentWithOptionalContext['mockExamScore']): string {
  if (typeof score !== 'number' || Number.isNaN(score)) {
    return '未入力';
  }
  return `${score}/100`;
}

export function buildPersonalizedContextDocument(student: MaybeStudent): string {
  const gradeLabel = formatGrade(student?.grade ?? null);
  const subjectLabel = formatSubject(student?.favoriteSubject ?? null);
  const mockScoreLabel = formatMockScore(student?.mockExamScore ?? null);

  const guidanceLines = [
    `- ${gradeLabel} に合わせて、段階的で理解しやすい説明を提供する。`,
    `- 例や比喩を使いながら、${subjectLabel} への興味を活かして他教科の内容ともつなげる。`,
    '- 自信を育てる声かけと、確認質問で理解度を確かめながら進める。'
  ];

  return [
    'Student Profile',
    `- Grade: ${gradeLabel}`,
    `- Favorite Subject: ${subjectLabel}`,
    `- Mock Exam Score: ${mockScoreLabel}`,
    '',
    'Guidance',
    ...guidanceLines
  ].join('\n');
}

function buildAutoSection(content: string): string {
  return `${AUTO_SECTION_START}\n${content}\n${AUTO_SECTION_END}`;
}

function mergeManualAndAuto(existingContent: string | null | undefined, autoSection: string): string {
  const current = (existingContent || '').trim();
  if (!current) {
    return autoSection;
  }

  const hasStart = current.includes(AUTO_SECTION_START);
  const hasEnd = current.includes(AUTO_SECTION_END);

  if (hasStart && hasEnd) {
    const startIndex = current.indexOf(AUTO_SECTION_START);
    const endIndex = current.indexOf(AUTO_SECTION_END);

    const before = current.slice(0, startIndex).trimEnd();
    const after = current.slice(endIndex + AUTO_SECTION_END.length).trimStart();

    const parts: string[] = [];
    if (before) parts.push(before);
    parts.push(autoSection);
    if (after) parts.push(after);
    return parts.join('\n\n');
  }

  return `${current}\n\n${autoSection}`;
}

async function getContextDocument(
  studentEmail: string,
  includeExisting?: StudentContextDocument | null
): Promise<StudentContextDocument | null> {
  if (includeExisting?.content) {
    return includeExisting;
  }

  return prisma.studentContextDocument.findUnique({
    where: { studentEmail }
  });
}

export async function ensureStudentContextDocument(
  student: MaybeStudent,
  { forceRegenerate = false }: { forceRegenerate?: boolean } = {}
): Promise<string | null> {
  if (!student?.email) {
    return null;
  }

  if (!student.grade || !student.favoriteSubject) {
    const existingDoc = await getContextDocument(student.email, student.contextDocument);
    return existingDoc?.content || null;
  }

  const autoContent = buildPersonalizedContextDocument(student);
  const autoSection = buildAutoSection(autoContent);

  let contextDocument = await getContextDocument(student.email, student.contextDocument);

  if (!contextDocument) {
    contextDocument = await prisma.studentContextDocument.create({
      data: {
        studentEmail: student.email,
        content: autoSection,
        isAutoGenerated: true
      }
    });
    return contextDocument.content;
  }

  if (!forceRegenerate && contextDocument.isAutoGenerated === false) {
    const mergedContent = mergeManualAndAuto(contextDocument.content, autoSection);

    if (mergedContent === contextDocument.content) {
      return contextDocument.content;
    }

    const updatedDoc = await prisma.studentContextDocument.update({
      where: { studentEmail: student.email },
      data: {
        content: mergedContent
      }
    });
    return updatedDoc.content;
  }

  const updatedDoc = await prisma.studentContextDocument.update({
    where: { studentEmail: student.email },
    data: {
      content: autoSection,
      isAutoGenerated: true
    }
  });

  return updatedDoc.content;
}

export { AUTO_SECTION_START, AUTO_SECTION_END };
